<a name="anchor-name-here" />
# Ember 2.0 with JWT auth #
The idea of this post is to show a very simple Ember 2.0 application that uses JSON Web Tokens (JWT) to authenticate to a protected API.

## What is Ember 2.0?
Ember is an MVC flavored framework, but in its 2.0 version this has changed to a components oriented approach, as you can see in the following image.

![ember evolution](Images/ember paradigm.PNG?raw=true)

_Ember evolution: from 1.x to 2.0_

Ember 2.0 does not introduce any new feature, as those features (Glimmer rendering engine, new computed syntax, HTML-style component invocation, and so on) are already in previous versions of Ember. In fact the dev team states that Ember latest stable release, v1.13, is Ember 2.0 in disguise. You have to take into account that those features deprecated in v1.x versions will be removed from 2.0.

This means that if you manage to create a v1.13 application with no deprecation warnings, then migrating to 2.0 will be straightforward as there will not be breaking changes.

### Using 2.0 with Ember-cli
As you may know ember-cli is a command line utility for developing Ember apps that is embraced by the dev team. However, the current release supports Ember v1.13. Therefore, to use Ember 2.0 and take advantage of ember-cli, we have to tweak a little the applications generated by it.

Once you created your ember application with ember-cli, edit the _bower.json_ file, look for the ember version, and replace it for _'**2.0.0-beta.3**'_. After that delete the _bower_components/ember_ folder and run: _bower install_ to fetch the 2.0 beta version. You may be prompted to manually choose the ember version as it cannot be resolved automatically, just choose **Ember 2.0.0 beta 3** to continue.

> **Note:** Take into account that this workaround is only needed because v2.0 is not the stable release, and it is highly likely that ember-cli will support 2.0 when it becomes stable.

## Creating a simple app that uses JWT
Our simple app will consist of a login form, and a page that shows a random quote obtained by calling the protected API. The server that will authenticate us and provide the secured API we will call, is Auth0's  [**NodeJS JWT Authentication Sample**](https://github.com/auth0/nodejs-jwt-authentication-sample).

Our app will have two routes: one for the login form and one for the one that shows the quote, as you can see in the following code.
<!-- mark:3-4 -->
````JavaScript
// router.js
Router.map(function() {
	this.route('login');
	this.route('protected');
});
````

To work with JWT we will utilize a very useful plugin called **Ember Simple Auth** that can be downloaded from [here](http://ember-simple-auth.com/). Follow the _how to use it_ instructions in the site to install it. This plugin will help us protect the routes as well as creating code to authenticate and authorize request.

On the application route, we will use the **ApplicationRouteMixin** which will create an application session and provide actions for authenticating or invalidating the session. You can see the application route code below, which has the **invalidate** action code.

````JavaScript
// app/routes/application.js
import Ember from 'ember';
import ApplicationRouteMixin from 'simple-auth/mixins/application-route-mixin';
export default Ember.Route.extend(ApplicationRouteMixin, {
    actions: {
        invalidateSession: function() {
            this.get('session').invalidate();
        }
    }
});
````

We will take advantage of the methods mentioned before to display login/logout buttons depending on the session's authentication state. This is done in the application template.
<!-- mark:3,5 -->
````JavaScript
// app/templates/application.hbs
{{#if session.isAuthenticated}}
  <p><a {{ action 'invalidateSession' }}>Logout</a></p>
{{else}}
  <p><a {{ action 'sessionRequiresAuthentication' }}>Login</a></p>
{{/if}}

````

Ember Simple Auth also provides the **AuthenticatedRouteMixin** mixin, to secure the routes that are only available when the user is authenticated. In our case it is the _protected_ route, as you can see below. If not authenticated it will trigger a redirection to the login route.
<!-- mark:3-6 -->
````JavaScript
// app/routes/protected.js
import Ember from 'ember';
import AuthenticatedRouteMixin from 'simple-auth/mixins/authenticated-route-mixin';

export default Ember.Route.extend(AuthenticatedRouteMixin, {  
}); 
````
Lastly, there is the **LoginControllerMixin** that allows you to specify the controller that will perform the login process.
<!-- mark:3-6 -->
````JavaScript
// app/controllers/login.js
import Ember from 'ember';
import LoginControllerMixin from 'simple-auth/mixins/login-controller-mixin';

export default Ember.Controller.extend(LoginControllerMixin, {
});
````
From here two new concepts arise: **Athenticators** & **Authorizators**.
Authenticators implement the logic necessary to authenticate the session. You can have one authenticator per authentication mechanism / provider you have. Authorizers on the other hand, uses the secret information adquired by the authenticator to authorize subsequent requests. 

You can see our custom implementations below:

````JavaScript
import Ember from 'ember';
import Base from 'simple-auth/authenticators/base';

export default Base.extend({
  tokenEndpoint: 'http://localhost:3001/sessions/create',
  restore: function(data) {
    return new Ember.RSVP.Promise(function (resolve, reject) {
      if (!Ember.isEmpty(data.session_name)) {
        resolve(data);
      }
      else {
        reject();
      }
    });
  },

  authenticate: function(options) { 
    return new Ember.RSVP.Promise(function(resolve, reject) { 
    Ember.$.ajax({ 
      url: tokenEndpoint, 
      type: 'POST', 
      data: JSON.stringify({
          username: options.identification,
          password: options.password
      }),
      contentType: 'application/json;charset=utf-8',
      dataType: 'json' 
    }).then(function(response) { 
      Ember.run(function() { 
        resolve({ token: response.id_token }); 
      }); 
    }, function(xhr, status, error) { 
      var response = JSON.parse(xhr.responseText); 
      Ember.run(function() { 
        reject(response.error); 
      }); 
    }); 
  }); 
}, 

  invalidate: function() {
    console.log('invalidate...');
    return Ember.RSVP.resolve();
  }
});
````

````JavaScript
// app/authorizators/custom.js
import Ember from 'ember';
import Base from 'simple-auth/authorizers/base';

export default Base.extend({
    authorize: function(jqXHR, requestOptions) { 
        var accessToken = this.get('session.content.token');
    	if (this.get('session.isAuthenticated') && !Ember.isEmpty(accessToken)) {
      		jqXHR.setRequestHeader('Authorization', 'Bearer ' + accessToken);
    	} 	
    } 
});
````
You can see that the **Authenticator** calls the token endpoint with the passed credentials and return the token. In the other hand, the **Authorizator**, gets the saved token and add the Authorization header in each Ajax call.

Components

