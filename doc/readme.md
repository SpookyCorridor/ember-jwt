<a name="anchor-name-here" />
# Ember 2.0 with JWT auth #
The purpose of this post is to show a very simple Ember 2.0 application that uses JSON Web Tokens (JWT) to authenticate to a protected API.

## What is Ember 2.0?
Ember is an MVC flavored framework, but in its 2.0 version this has changed to a components oriented approach, as you can see in the following image.

![ember evolution](Images/ember paradigm.PNG?raw=true)

_Ember evolution: from 1.x to 2.0_

Ember 2.0 does not introduce any new feature, as those features (Glimmer rendering engine, new computed syntax, HTML-style component invocation, and more) are already in previous versions of Ember. In fact the dev team states that Ember latest stable release v1.13, is Ember 2.0 in disguise. You have to take into account that those features deprecated in v1.x versions will be removed from 2.0.

This means that if you manage to create a v1.13 application with no deprecation warnings, then migrating to 2.0 will be straightforward as there will not be breaking changes.

### Using 2.0 with Ember-cli
As you may know ember-cli is a command line utility for developing Ember apps that is embraced by the dev team. However, the current release supports Ember v1.13. Therefore, to use Ember 2.0 and take advantage of ember-cli, we have to tweak a little the applications generated by it.

Once you created your ember application with ember-cli, edit the _bower.json_ file, look for the ember version, and replace it for _'**2.0.0-beta.3**'_. After that delete the _bower_components/ember_ folder and run: _bower install_ to fetch the 2.0 beta version. You may be prompted to manually choose the ember version as it cannot be resolved automatically, just choose **Ember 2.0.0 beta 3** to continue.

> **Note:** Take into account that this workaround is only needed because v2.0 is not the stable release, and it is highly likely that ember-cli will support 2.0 when it becomes stable.

## Creating a simple app that uses JWT
Our simple app will consist of a login form, and a page that shows a random quote obtained by calling the protected API. The server that will authenticate us and provide the secured API we will call, is Auth0's  [**NodeJS JWT Authentication Sample**](https://github.com/auth0/nodejs-jwt-authentication-sample).

Our app will have two routes: one for the login form and one for the one that shows the quote, as you can see in the following code.
<!-- mark:3-4 -->
````JavaScript
// router.js
Router.map(function() {
	this.route('login');
	this.route('protected');
});
````

To work with JWT we will utilize a very useful plugin called **Ember Simple Auth** that can be downloaded from [here](http://ember-simple-auth.com/). Follow the _how to use it_ instructions in the site to install it. This plugin will help us protect the routes as well as creating code to authenticate and authorize request.

On the application route, we will use the **ApplicationRouteMixin** which will create an application session and provide actions for authenticating or invalidating the session. You can see the application route code below, which has the **invalidate** action code.

````JavaScript
// app/routes/application.js
import Ember from 'ember';
import ApplicationRouteMixin from 'simple-auth/mixins/application-route-mixin';
export default Ember.Route.extend(ApplicationRouteMixin, {
    actions: {
        invalidateSession: function() {
            this.get('session').invalidate();
        }
    }
});
````

We will take advantage of the methods mentioned before to display login/logout buttons depending on the session's authentication state. This is done in the application template.
<!-- mark:3,5 -->
````JavaScript
// app/templates/application.hbs
{{#if session.isAuthenticated}}
  <p><a {{ action 'invalidateSession' }}>Logout</a></p>
{{else}}
  <p><a {{ action 'sessionRequiresAuthentication' }}>Login</a></p>
{{/if}}

````

Ember Simple Auth also provides the **AuthenticatedRouteMixin** mixin, to secure the routes that are only available when the user is authenticated. In our case it is the _protected_ route, as you can see below. If not authenticated it will trigger a redirection to the login route.
<!-- mark:3-6 -->
````JavaScript
// app/routes/protected.js
import Ember from 'ember';
import AuthenticatedRouteMixin from 'simple-auth/mixins/authenticated-route-mixin';

export default Ember.Route.extend(AuthenticatedRouteMixin, {  
}); 
````
Lastly, there is the **LoginControllerMixin** that allows you to specify the controller that will perform the login process.
<!-- mark:3-6 -->
````JavaScript
// app/controllers/login.js
import Ember from 'ember';
import LoginControllerMixin from 'simple-auth/mixins/login-controller-mixin';

export default Ember.Controller.extend(LoginControllerMixin, {
});
````
From here two new concepts arise: **Athenticators** & **Authorizators**.
Authenticators implement the logic necessary to authenticate the session. You can have one authenticator per authentication mechanism / provider you have. Authorizers on the other hand, uses the secret information adquired by the authenticator to authorize subsequent requests. 

You can see our custom implementations below:

````JavaScript
// app/authenticators/custom.js
import Ember from 'ember';
import Base from 'simple-auth/authenticators/base';

export default Base.extend({
  tokenEndpoint: 'http://localhost:3001/sessions/create',
  restore: function(data) {
    return new Ember.RSVP.Promise(function (resolve, reject) {
      if (!Ember.isEmpty(data.session_name)) {
        resolve(data);
      }
      else {
        reject();
      }
    });
  },

  authenticate: function(options) { 
    var self = this;
    return new Ember.RSVP.Promise(function(resolve, reject) { 
    Ember.$.ajax({ 
      url: self.tokenEndpoint, 
      type: 'POST', 
      data: JSON.stringify({
          username: options.identification,
          password: options.password
      }),
      contentType: 'application/json;charset=utf-8',
      dataType: 'json' 
    }).then(function(response) { 
      Ember.run(function() { 
        resolve({ token: response.id_token }); 
      }); 
    }, function(xhr, status, error) { 
      var response = JSON.parse(xhr.responseText); 
      Ember.run(function() { 
        reject(response.error); 
      }); 
    }); 
  }); 
}, 

  invalidate: function() {
    console.log('invalidate...');
    return Ember.RSVP.resolve();
  }
});
````

````JavaScript
// app/authorizators/custom.js
import Ember from 'ember';
import Base from 'simple-auth/authorizers/base';
export default Base.extend({
    authorize: function(jqXHR, requestOptions) {
        var accessToken = this.get('session.content.secure.token');
        if (this.get('session.isAuthenticated') && !Ember.isEmpty(accessToken)) {
            jqXHR.setRequestHeader('Authorization', 'Bearer ' + accessToken);
        }
    }
});
````
You can see that the **Authenticator** calls the token endpoint with the passed credentials and return the token, it also has methods to invalidate the session and to restore it. In the other hand, the **Authorizator**, gets the saved token and add the Authorization header in each Ajax call.

The last important thing you have to take into account about the plugin, is to correctly configure it. To do this, in the environment.js set the desired configuration properties.

- **store**: This specifies where the session state will persist so it survives page reload. In this case is set to use the local storage.
- **authorizer**: This property specifies the authorizator that will be used. In our case is the custom authorizator.
- **crossOriginWhitelist**: This is a very important property for our scenario. By default the ember simple auth plugin will not authorize requests going to a different origin than the one the Ember.js application was loaded from. Therefore we have to explicitely enable authorization for additional origins, such as the origin of the NodeJS JWT Authentication Sample.
- **routeAfterAuthentication**: This property defines the route that the app will redirect to after successful authentication. In our example, that will be the _protected_ route.

You can see the _environment.js_ file for our sample below.

````C#
// config/environment.js
...
ENV['simple-auth'] = {
    store: 'simple-auth-session-store:local-storage',
    authorizer: 'authorizer:custom',
    crossOriginWhitelist: ['http://localhost:3001/'],
    routeAfterAuthentication: '/protected'
};
...
````

###Components
As we mentioned at the start of the post, Ember 2.0 approach for creating applications has changed to component driven. Therefore, we created components for our login form view and for the protected view.

Ember components are based on of the [W3C Web Components specification](http://www.w3.org/TR/components-intro), they are views that are completely isolated. Properties accessed in its templates go to the view object and actions are targeted at the view object. There is no access to the surrounding context or outer controller; all contextual information must be passed in. Components should have a well defined interface to the outside world and can broadcast events. You can see a component definition in the following image.

![Component Definition](Images/component-definition.PNG?raw=true)


> **Note**: In the future Ember 2.1, the dev team is planning to add [**Routeable components**](https://github.com/emberjs/rfcs/blob/master/text/0015-the-road-to-ember-2-0.md#routeable-components), which will simplify the way in which a route can simple redirect to a component instead of a view.


> As a final comment, take into account that you may receive deprecation warnings due to the way that the **Ember Simple Auth** plugin access Ember's container. You can just ignore this warning for the meantime, as we expect that the plugin will be updated when Ember 2.0 is released.

Hope this has been useful to you.

Diego
